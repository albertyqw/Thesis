% rumination model
%% pre-processing

loadData

nhidden = 100; % 144 % number of hidden units - modulate - see Hinton's recipe
epsilon = 0.005; % meets Hinton's guidelines, seems to be an okay value for our learning
maxEpochs = 2; % 8; for long % number of training epochs, 6 doesn't completely settle - but learning isn't perfect
cdk = 1; % contrastive-divergence steps

v0 = rand(Ni+28,1); % pure noisy input for rumination, with an extra row

trValence = [];
tsValence = [];

% store labels and scale
for a = 1:size(trLabels, 1)
    for b = 1:size(trLabels, 2)
        if trLabels(a,b) == 1
            trValence = [trValence;(b-1)/10]; % currently, valence = number, scaled to [0,1]
            break
        end
    end
end

for c = 1:size(tsLabels, 1)
    for d = 1:size(tsLabels, 2)
        if tsLabels(c,d) == 1
            tsValence = [tsValence;(d-1)/10];
            break
        end
    end
end

% create a column of valence labels
trValence = repmat(trValence, 1, 28); % add 28x1 to each row (try 28x2)
tsValence = repmat(tsValence, 1, 28);

% add valence columns to images
trImagesL = [trImages, trValence];
tsImagesL = [tsImages, tsValence]; 

%% train

[M_c, b_c, c_c, errors_c, energies_c, tsPredY] = rbm_mood(epsilon, Ni+28, trImagesL, tsImagesL, trLabels, nhidden, maxEpochs, cdk); % Ni + 28 for labels 

% equalize training
M_e = M_c;
b_e = b_c;
c_e = c_c;
errors_e = errors_c;

est_tsValences = amygdala(tsPredY); % getting weighted learned valences

% heatmap of weights
figure
title("Weights Heatmap")
heatmap(M_c);

% get estimated "valence" from softmax
% est_trValences = [];
% est_tsValences = [];

% for a = 1:size(trPredY, 2)
    % estValence(end+1) = dot([0:9], trPredY(:,a));
% end

% for b = 1:size(tsPredY, 2)
    % tsValence(end+1) = dot([0:9], tsPredY(:,b));
% end
%% recall tests
%% independent associative recall

ts = [4,3,2,19,5,9,12,18,62,8]; % samples 0:9, associative recall

cBreadth = 0.90; % 0.90 % of neurons kept on for the control case
eBreadth = 0.80; % 0.80 """ for the experimental (trait rumination case)

aCycles = 3; % number of AR sampling points

% maxcdk_c = acdk_c*acycles*length(ts); % max cdk counter
% maxcdk_e = acdk_e*acycles*length(ts);

% errors and energies for ctl. vs exp.
errors_cAR = [];
energies_cAR = [];
errors_eAR = [];
energies_eAR = [];

% store 
pred_error_c = [];
pred_error_e = [];

mood_c = 0;
mood_e = 0;

% temperatures
T_c = 1.1; 
T_e = 0.9;

% valence prediction store
im_pred_c = 0;
im_pred_e = 0;

figure
for i = 1:length(ts) % can sub ts_dys for dysphoric induction
    acdk_c = 80; % associative recall k-steps / cycle
    acdk_e = 80;

    acdk_c = mood_bias(mood_c(i+1), valences(ts(i)), acdk_c); % mood congruent-effects
    acdk_e = mood_bias(mood_e(i+1), valences(ts(i)), acdk_e);

    % maxcdk_c = maxcdk_c - acdk_c;
    % maxcdk_e = maxcdk_c - acdk_c;

    % check if attentional resources are overconsumed
    % if maxcdk_c < 0
        % acdk_c = acdk_c+maxcdk_c;
        % maxcdk_c = 0;
    % end
    
    [error_cAR, energy_cAR, im_pred_c] = AR(M_c, acdk_c, b_c, c_c, tsImagesL(ts(i),:), mean(tsPredY(ts(i))), ...
        "ctl.", nhidden, cBreadth, aCycles, T_c, mood_c(i+1)); % mood adjusted
    [error_eAR, energy_eAR, im_pred_e] = AR(M_e, acdk_e, b_e, c_e, tsImagesL(ts(i),:), mean(tsPredY(ts(i))), ...
        "exp.", nhidden, eBreadth, aCycles, T_e, mood_e(i+1));

    errors_cAR = [errors_cAR; error_cAR]; % adding statistics to matrix
    energies_cAR = [energies_cAR; energy_cAR];
    errors_eAR = [errors_eAR; error_eAR];
    energies_eAR = [energies_eAR; energy_eAR];

    pred_error_c(end+1) = im_pred_c;
    pred_error_e(end+1) = im_pred_e;
end
%% dysphoric induction AR

ts_dys = [18,27,35,37,42,12,22,23,51,55]; % samples 3s then 7s, dysphoric induction followed by mood lifting

mood_c = zeros(length(ts)+1); % control and experimental mood calculation
mood_e = zeros(length(ts)+1);




%% 
% free recall
rcdk = 40; % # k-steps per free recall
rCycles = 6; % number of ruminative "cycles" (giving us 4*30=120 total k-steps)

figure
energies_cFR = FR(M_c, rcdk, b_c, c_c, v0, nhidden, cBreadth, rCycles, T_c);
energies_eFR = FR(M_e, rcdk, b_e, c_e, v0, nhidden, eBreadth, rCycles, T_e);
%%
% distraction tests

mood_c = 0; % control and experimental mood counter
mood_e = 0;

pred_error_c = [];
pred_error_e = [];

% temperatures
T_c = 1.1;
T_e = 0.9;

% valence prediction store
val_pred_c = 0;
val_pred_e = 0;

figure
for i = 1:length(ts)
    acdk_c = 240; % associative recall k-steps
    acdk_e = 240;

    mood_c = (mood_c + valences(ts(i)) + val_pred_c)/(2*i); % mood calculation - add decay
    mood_e = (mood_e + valences(ts(i)) + val_pred_e)/(2*i);

    acdk_c = mood_bias(mood_c, valences(ts(i)), acdk_c); % mood congruent-effects
    acdk_e = mood_bias(mood_e, valences(ts(i)), acdk_e);

    [errors_cAR_d, energies_cAR_d, val_pred_c_d] = distractionAR(M_c, acdk, b_c, c_c, tsImagesL(ts(i),:), i, ...
        "ctl.", nhidden, cBreadth, T_c, mood_c); % mood adjusted
    [errors_eAR_d, energies_eAR_d, val_pred_e_d] = distractionAR(M_e, acdk, b_e, c_e, tsImagesL(ts(i),:), i, ...
        "exp.", nhidden, eBreadth, T_e, mood_e);
    pred_error_c(end+1) = val_pred_c;
    pred_error_e(end+1) = val_pred_e;
end
%%
ave_pred_error_c = (sum(abs([0:9]-pred_error_c)))/10;
ave_pred_error_e = (sum(abs([0:9]-pred_error_e)))/10;
%% final results
fprintf("Ave. ctl. predicted error, %f \n", ave_pred_error_c);
fprintf("Ave. exp. predicted error, %f \n", ave_pred_error_e);

% energy
figure(1)
plot(Single')
grid
xlabel('steps')
ylabel('Ctl. AR energies')

xv = linspace(0,1, size(energies_cAR,2));

figure(2)
plot(xv, Single)
grid
xlabel('steps')
ylabel('energy')
%%
figure
subplot(2,1,1)
x = 1:size(energies_cAR, 2);
y1 = energies_cAR;
plot(x,y1)
title(sprintf("Ctl. AR energy"))
xlabel('steps');
ylabel('energy');

subplot(2,1,2);
y2 = energies_eAR;
plot(x,y2)
title(sprintf("Exp. AR energy"));
xlabel('steps');
ylabel('energy');

% error
figure
subplot(2,1,1)
x = 1:size(errors_cAR, 2);
y1 = errors_cAR;
plot(x,y1)
title(sprintf("Ctl. AR error"))
xlabel('steps');
ylabel('error');

subplot(2,1,2);
y2 = errors_eAR;
plot(x,y2)
title(sprintf("Exp. AR error"));
xlabel('steps');
ylabel('error');

% free recall
figure
subplot(2,1,1)
x = 1:size(energies_cFR, 2);
y1 = energies_cFR;
plot(x,y1)
title(sprintf("Ctl. FR energy"))
xlabel('steps');
ylabel('energy');

subplot(2,1,2);
y2 = energies_eFR;
plot(x,y2)
title(sprintf("Exp. FR energy"));
xlabel('steps');
ylabel('energy');